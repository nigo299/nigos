import{_ as e,o,c as d,b as c}from"./app-Zy-6XiuU.js";const i={},t=c(`<h3 id="vue-react-diff-算法有什么区别" tabindex="-1"><a class="header-anchor" href="#vue-react-diff-算法有什么区别" aria-hidden="true">#</a> Vue React diff 算法有什么区别</h3><p><strong>diff 算法</strong></p><ul><li><code>Vue React diff</code> 不是对比文字，而是 <code>vdom</code> 树，即 <code>tree diff</code></li><li>传统的 <code>tree diff</code> 算法复杂度是 <code>O(n^3)</code> ，算法不可用。</li></ul><p><img src="https://nigo299.github.io/nigos/react10.png" alt="img"></p><p><strong>优化</strong></p><blockquote><p><code>Vue React</code> 都是用于网页开发，基于 <code>DOM</code> 结构，对 <code>diff</code> 算法都进行了优化（或者简化）</p></blockquote><ul><li>只在同一层级比较，不跨层级（<code>DOM</code> 结构的变化，很少有跨层级移动）</li><li><code>tag</code> 不同则直接删掉重建，不去对比内部细节（<code>DOM</code> 结构变化，很少有只改外层，不改内层）</li><li>同一个节点下的子节点，通过 <code>key</code> 区分</li></ul><blockquote><p>最终把时间复杂度降低到 <code>O(n)</code> ，生产环境下可用。这一点 <code>Vue React</code> 都是相同的。</p></blockquote><p><img src="https://nigo299.github.io/nigos/react12.png" alt="img"></p><p><strong>React diff 特点 - 仅向右移动</strong></p><blockquote><p>比较子节点时，仅向右移动，不向左移动。</p></blockquote><p><img src="https://nigo299.github.io/nigos/react11.png" alt="img"></p><p><strong>Vue2 diff 特点 - 双端比较</strong></p><p><img src="https://nigo299.github.io/nigos/react13.png" alt="img"></p><p>定义四个指针，分别比较</p><ul><li><code>oldStartNode</code> 和 <code>newStartNode</code> 头头</li><li><code>oldStartNode</code> 和 <code>newEndNode</code> 头尾</li><li><code>oldEndNode</code> 和 <code>newStartNode</code> 尾头</li><li><code>oldEndNode</code> 和 <code>newEndNode</code> 尾尾</li></ul><blockquote><p>然后指针继续向中间移动，直到指针汇合</p></blockquote><p><strong>Vue3 diff 特点 - 最长递增子序列</strong></p><blockquote><p>例如数组 <code>[3，5，7，1，2，8]</code> 的最长递增子序列就是 <code>[3，5，7，8 ]</code> 。这是一个专门的算法。</p></blockquote><p><img src="https://nigo299.github.io/nigos/react14.png" alt="img"></p><p><strong>算法步骤</strong></p><ul><li><p>通过“前-前”比较找到开始的不变节点 <code>[A, B]</code></p></li><li><p>通过“后-后”比较找到末尾的不变节点 <code>[G]</code></p></li><li><p>剩余的有变化的节点</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>[F, C, D, E, H]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>通过 <code>newIndexToOldIndexMap</code> 拿到 <code>oldChildren</code> 中对应的 <code>index</code> <code>[5, 2, 3, 4, -1]</code> （<code>-1</code> 表示之前没有，要新增）</li><li>计算<strong>最长递增子序列</strong>得到 <code>[2, 3, 4]</code> ，对应的就是 <code>[C, D, E]</code> ，即这些节点可以不变</li><li>剩余的节点，根据 <code>index</code> 进行新增、删除</li></ul></li></ul><blockquote><p>该方法旨在尽量减少 <code>DOM</code> 的移动，<code>达到最少的DOM操作</code>。</p></blockquote><p><strong>总结</strong></p><ul><li><p><code>React diff</code> 特点 - 仅向右移动</p></li><li><p><code>Vue2 diff</code> 特点 - <code>updateChildren</code>双端比较</p></li><li><p><code>Vue3 diff</code> 特点 - <code>updateChildren</code>增加了最长递增子序列，更快</p><ul><li>Vue3 增加了 patchFlag、静态提升、函数缓存等</li></ul></li></ul>`,25),l=[t];function n(p,a){return o(),d("div",null,l)}const r=e(i,[["render",n],["__file","Vue React diff suanfayoushimequbie.html.vue"]]);export{r as default};
