import{_ as e,o,c,b as d}from"./app-Zy-6XiuU.js";const i={},l=d(`<h3 id="react-组件渲染过程" tabindex="-1"><a class="header-anchor" href="#react-组件渲染过程" aria-hidden="true">#</a> react 组件渲染过程</h3><ul><li><code>JSX</code>如何渲染为页面</li><li><code>setState</code>之后如何更新页面</li><li>面试考察全流程</li></ul><p><strong>1.组件渲染过程</strong></p><ul><li>分析 <ul><li><code>props</code>、<code>state</code> 变化</li><li><code>render()</code>生成<code>vnode</code></li><li><code>patch(elem, vnode)</code> 渲染到页面上（<code>react</code>并一定用<code>patch</code>）</li></ul></li><li>渲染过程 <ul><li><code>setState(newState)</code> =&gt; <code>newState</code>存入<code>pending</code>队列，判断是否处于<code>batchUpdate</code>状态，保存组件于<code>dirtyComponents</code>中（可能有子组件） <img src="https://nigo299.github.io/nigos/react3.png" alt="img"></li><li>遍历所有的<code>dirtyComponents</code>调用<code>updateComponent</code>生成<code>newVnode</code></li><li><code>patch(vnode,newVnode)</code></li></ul></li></ul><p><strong>2.组件更新过程</strong></p><ul><li><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>patch
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>更新被分为两个阶段</p><ul><li><strong>reconciliation 阶段</strong>：执行<code>diff</code>算法，纯<code>JS</code>计算</li><li><strong>commit 阶段</strong>：将<code>diff</code>结果渲染到<code>DOM</code>中</li></ul></li><li><p>如果不拆分，可能有性能问题</p><ul><li><code>JS</code>是单线程的，且和<code>DOM</code>渲染共用一个线程</li><li>当组件足够复杂，组件更新时计算和渲染都压力大</li><li>同时再有<code>DOM</code>操作需求（动画、鼠标拖拽等）将卡顿</li></ul></li><li><p>解决方案 Fiber</p><ul><li><code>reconciliation</code>阶段拆分为多个子任务</li><li><code>DOM</code>需要渲染时更新，空闲时恢复在执行计算</li><li>通过<code>window.requestIdleCallback</code>来判断浏览器是否空闲</li></ul></li></ul>`,6),t=[l];function n(a,r){return o(),c("div",null,t)}const u=e(i,[["render",n],["__file","reactzujianxuanranguocheng.html.vue"]]);export{u as default};
