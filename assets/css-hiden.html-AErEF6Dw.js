import{_ as e,o as i,c as o,b as d}from"./app-Zy-6XiuU.js";const c={},l=d("<ul><li><code>opacity:0</code>：本质上是将元素的透明度将为<code>0</code>，就看起来隐藏了，但是依然占据空间且可以交互</li><li><code>display:none</code>: 这个是彻底隐藏了元素，元素从文档流中消失，既不占据空间也不交互，也不影响布局</li><li><code>visibility:hidden</code>: 与上一个方法类似的效果，占据空间，但是不可以交互了</li><li><code>overflow:hidden</code>: 这个只隐藏元素溢出的部分，但是占据空间且不可交互</li><li><code>z-index:-9999</code>: 原理是将层级放到底部，这样就被覆盖了，看起来隐藏了</li><li><code>transform:scale(0,0)</code>: 平面变换，将元素缩放为<code>0</code>，但是依然占据空间，但不可交互</li></ul><p><strong>display: none 与 visibility: hidden 的区别</strong></p><ul><li>修改常规流中元素的<code>display</code>通常会造成文档重排。修改<code>visibility</code>属性只会造成本元素的重绘</li><li>读屏器不会读取<code>display:none</code>;元素内容；会读取<code>visibility:hidden;</code>元素内容</li><li><code>display:none</code>;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；<code>visibility:hidden</code>;不会让元素从渲染树消失，渲染时元素继续占据空间，只是内容不可见</li><li><code>display:none</code>;是非继承属性，<strong>子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示</strong>；<code>visibility:hidden;</code>是继承属性，<strong>子孙节点消失由于继承了<code>hidden</code>，通过设置<code>visibility:visible;</code>可以让子孙节点显式</strong></li></ul>",3),n=[l];function s(t,r){return i(),o("div",null,n)}const _=e(c,[["render",s],["__file","css-hiden.html.vue"]]);export{_ as default};
